"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printTree = void 0;
var tslib_1 = require("tslib");
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var support_1 = require("./support");
var SYMBOLS = {
    BRANCH: '├── ',
    EMPTY: '',
    INDENT: '    ',
    LAST_BRANCH: '└── ',
    VERTICAL: '│   ',
};
function isHiddenFile(filename) {
    return filename[0] === '.';
}
var COLORS = [
    chalk_1.default.blue,
    chalk_1.default.cyan,
    chalk_1.default.green,
    chalk_1.default.magenta,
    chalk_1.default.italic,
    chalk_1.default.greenBright,
];
function print(node, currentDepth, precedingSymbols, options, isLast) {
    if (isLast === void 0) { isLast = false; }
    var isDir = node.type === 'directory';
    // We treat all non-directory paths as files and don't
    // recurse into them, including symlinks, sockets, etc.
    var isFile = !isDir;
    var lines = [];
    // Handle directories only.
    if (isFile && options.dirsOnly) {
        return lines;
    }
    // Handle max depth.
    if (currentDepth > options.maxDepth) {
        return lines;
    }
    // Handle current file.
    var line = [precedingSymbols];
    if (currentDepth >= 1) {
        line.push(isLast ? SYMBOLS.LAST_BRANCH : SYMBOLS.BRANCH);
    }
    line.push(node.name);
    if (isDir && options.trailingSlash) {
        line.push('/');
    }
    // ADD THE CONTRIBUTOR INFO
    if (!node.topContributorDetails.percentage) {
        return lines;
    }
    var author = node.topContributorDetails.author;
    var percentage = (node.topContributorDetails.percentage * 100).toFixed(0) + '%';
    var color = options.colors[author];
    if (!color) {
        var l = Object.keys(options.colors).length;
        var i = support_1.numInRange(l, [0, COLORS.length - 1]);
        // console.log({ i })
        color = COLORS[i];
        options.colors[author] = color;
    }
    line.push(' ' +
        support_1.meaningfulColor(node.topContributorDetails.accumulatedLinesCount /
            node.topContributorDetails.percentage));
    var postfix = " " + color(('   ' + percentage).slice(-4)) + " " + author;
    line.push(options.alignRight ? support_1.alignRight(line.join(''), postfix) : postfix);
    lines.push(line.join(''));
    if (isFile) {
        return lines;
    }
    // Contents of a directory.
    var dirFiles = (node.children || []).map(function (x) { return x.name; });
    if (options.reverse) {
        dirFiles.reverse();
    }
    // Handle showing of all files.
    if (!options.allFiles) {
        dirFiles = dirFiles.filter(function (content) { return !isHiddenFile(content); });
    }
    // TODO options.dirsOnly
    // if TODO (options.dirsOnly) {
    //     // We have to filter here instead of at the start of the function
    //     // because we need to know how many non-directories there are before
    //     // we even start recursing.
    //     dirFiles = dirFiles.filter((file) =>
    //         fs.lstatSync(nodePath.join(path, file)).isDirectory(),
    //     )
    // }
    // // TODO Sort directories first.
    // if (options.dirsFirst) {
    //     const dirs = dirFiles.filter((content) =>
    //         fs.lstatSync(nodePath.join(path, content)).isDirectory(),
    //     )
    //     const files = dirFiles.filter(
    //         (content) =>
    //             !fs.lstatSync(nodePath.join(path, content)).isDirectory(),
    //     )
    //     dirFiles = [].concat(dirs, files)
    // }
    node.children.forEach(function (child, index) {
        var isCurrentLast = index === dirFiles.length - 1;
        var linesForFile = print(child, currentDepth + 1, precedingSymbols +
            (currentDepth >= 1
                ? isLast
                    ? SYMBOLS.INDENT
                    : SYMBOLS.VERTICAL
                : SYMBOLS.EMPTY), options, isCurrentLast);
        lines.push.apply(lines, linesForFile);
    });
    return lines;
}
var DEFAULT_OPTIONS = {
    alignRight: true,
    allFiles: false,
    dirsFirst: false,
    dirsOnly: false,
    exclude: [],
    maxDepth: Number.POSITIVE_INFINITY,
    reverse: false,
    trailingSlash: false,
    colors: {},
};
function printTree(node, options) {
    if (options === void 0) { options = {}; }
    var combinedOptions = Object.assign({}, DEFAULT_OPTIONS, options);
    return print(node, 0, '', combinedOptions, false).join('\n');
}
exports.printTree = printTree;
//# sourceMappingURL=print.js.map