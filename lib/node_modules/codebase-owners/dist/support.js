"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrangeIntoTree = exports.gitDirectoryTree = exports.meaningfulColor = exports.sum = exports.numInRange = exports.alignRight = exports.weightedAverage = exports.average = exports.bfs = exports.makeHist = exports.arrayMax = exports.getFileOwners = void 0;
var tslib_1 = require("tslib");
var util = require('util');
var chalk_1 = tslib_1.__importDefault(require("chalk"));
var promisify_child_process_1 = require("promisify-child-process");
// export const exec = util.promisify(exec_)
var DEFAULT_AUTHOR_REGEX = /\nauthor-mail <(.*)>/g;
// TODO filter by only one author email, see only that author percentages
function getFileOwners(_a) {
    var filePath = _a.filePath, _b = _a.regex, regex = _b === void 0 ? DEFAULT_AUTHOR_REGEX : _b;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var stdout, data, match, results, authorEmail, _c;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _d.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, promisify_child_process_1.exec("git blame -w --line-porcelain " + filePath, {
                            maxBuffer: 1024 * 10000,
                        })];
                case 1:
                    stdout = (_d.sent()).stdout;
                    data = stdout.toString();
                    match = void 0;
                    results = [];
                    while ((match = regex.exec(data.toString())) !== null) {
                        authorEmail = match[1] || '';
                        if (authorEmail && authorEmail !== 'not.committed.yet') {
                            results.push(authorEmail);
                        }
                        // expected output: "Found foo. Next starts at 9."
                        // expected output: "Found foo. Next starts at 19."
                    }
                    return [2 /*return*/, results];
                case 2:
                    _c = _d.sent();
                    return [2 /*return*/, []];
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.getFileOwners = getFileOwners;
function arrayMax(arr, getter) {
    return arr.reduce(function (p, v) {
        return getter(p) > getter(v) ? p : v;
    });
}
exports.arrayMax = arrayMax;
function makeHist(data) {
    var hist = {};
    data.forEach(function (x) {
        if (hist[x]) {
            hist[x]++;
        }
        else {
            hist[x] = 1;
        }
    });
    return hist;
}
exports.makeHist = makeHist;
function bfs(tree) {
    var results = [];
    tree.depth = 0;
    var queue = [tree];
    var n;
    while (queue.length > 0) {
        n = queue.shift();
        results.push(n);
        if (!n.children) {
            continue;
        }
        for (var i = 0; i < n.children.length; i++) {
            var child = n.children[i];
            child.depth = (n.depth || 0) + 1;
            queue.push(child);
        }
    }
    return results;
}
exports.bfs = bfs;
exports.average = function (array) {
    return array.reduce(sum, 0) / array.length;
};
exports.weightedAverage = function (array, weights) {
    if (weights.length !== array.length) {
        throw new Error('weightedAverage got weights with different length from array');
    }
    var weightSum = weights.reduce(function (a, b) { return a + b; }, 0);
    var normalizedWeights = weights.map(function (x) { return x / weightSum; });
    // console.log({ normalizedWeights })
    var weightedArray = array.map(function (x, i) { return x * normalizedWeights[i]; });
    return (weightedArray.reduce(function (a, b) { return a + b; }, 0) /
        normalizedWeights.reduce(function (a, b) { return a + b; }, 0));
};
function alignRight(str, toAdd, length, maxSpace) {
    if (length === void 0) { length = 100; }
    if (maxSpace === void 0) { maxSpace = 48; }
    if (toAdd.length > maxSpace) {
        toAdd = toAdd.slice(0, maxSpace - 3) + '...';
    }
    else {
        toAdd =
            toAdd +
                Array(maxSpace - toAdd.length)
                    .fill(' ')
                    .join('');
    }
    var paddingLength = length - str.length - maxSpace;
    paddingLength = paddingLength < 0 ? 0 : paddingLength;
    return Array(paddingLength).fill(' ').join('') + toAdd;
}
exports.alignRight = alignRight;
function numInRange(x, range, includeMax) {
    if (includeMax === void 0) { includeMax = true; }
    var max = range[1], min = range[0], d = max - min;
    return x === max && includeMax ? x : ((x - min) % d) + min;
}
exports.numInRange = numInRange;
function sum(a, b) {
    return a + b;
}
exports.sum = sum;
function meaningfulColor(x) {
    if (x < 100) {
        return chalk_1.default.gray(x);
    }
    else if (x < 400) {
        return chalk_1.default.greenBright(x);
    }
    else if (x < 1000) {
        return chalk_1.default.yellow(x);
    }
    else if (x < 5000) {
        return chalk_1.default.redBright(nFormatter(x));
    }
    else {
        return chalk_1.default.red(nFormatter(x));
    }
}
exports.meaningfulColor = meaningfulColor;
function nFormatter(num) {
    if (num >= 1000000000) {
        return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + 'G';
    }
    if (num >= 1000000) {
        return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
    }
    if (num >= 1000) {
        return (num / 1000).toFixed(1).replace(/\.0$/, '') + 'K';
    }
    return num;
}
function gitDirectoryTree(cwd, options) {
    if (options === void 0) { options = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var stdout, paths, nodes;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, promisify_child_process_1.exec("git ls-files " + cwd, {
                        maxBuffer: 1024 * 10000,
                    })];
                case 1:
                    stdout = (_a.sent()).stdout;
                    paths = stdout
                        .toString()
                        .split('\n')
                        .map(function (x) { return x.trim(); })
                        .filter(Boolean);
                    nodes = arrangeIntoTree(paths.map(function (x) {
                        return x
                            .split('/')
                            .map(function (x) { return x.trim(); })
                            .filter(Boolean);
                    }));
                    return [2 /*return*/, {
                            name: cwd.split('/').slice(-1)[0],
                            path: cwd,
                            type: 'directory',
                            children: nodes,
                        }];
            }
        });
    });
}
exports.gitDirectoryTree = gitDirectoryTree;
function arrangeIntoTree(paths) {
    // Adapted from http://brandonclapp.com/arranging-an-array-of-flat-paths-into-a-json-tree-like-structure/
    var tree = [];
    for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        var currentLevel = tree;
        for (var j = 0; j < path.length; j++) {
            var part = path[j];
            var existingPath = findWhere(currentLevel, 'name', part);
            if (existingPath) {
                currentLevel = existingPath.children;
            }
            else {
                var reconstructedPath = path.slice(0, j + 1).join('/');
                // remove url for non leafs
                var newPart = {
                    name: part,
                    type: part[j + 1] ? 'directory' : 'file',
                    path: reconstructedPath,
                    children: [],
                };
                currentLevel.push(newPart);
                currentLevel = newPart.children;
            }
        }
    }
    return tree;
    function findWhere(array, key, value) {
        // Adapted from https://stackoverflow.com/questions/32932994/findwhere-from-underscorejs-to-jquery
        var t = 0; // t is used as a counter
        while (t < array.length && array[t][key] !== value) {
            t++;
        } // find the index where the id is the as the aValue
        if (t < array.length) {
            return array[t];
        }
        else {
            return false;
        }
    }
}
exports.arrangeIntoTree = arrangeIntoTree;
//# sourceMappingURL=support.js.map