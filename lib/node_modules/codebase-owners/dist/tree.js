"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGitIgnoreRegexes = exports.makeTreeWithInfo = void 0;
var tslib_1 = require("tslib");
var batched_promise_all_1 = require("batched-promise-all");
var cli_progress_1 = tslib_1.__importDefault(require("cli-progress"));
var find_up_1 = tslib_1.__importDefault(require("find-up"));
var gitignore_to_glob_1 = tslib_1.__importDefault(require("gitignore-to-glob"));
var glob_to_regexp_1 = tslib_1.__importDefault(require("glob-to-regexp"));
var lodash_1 = require("lodash");
var os_1 = tslib_1.__importDefault(require("os"));
var support_1 = require("./support");
var CONCURRENT_IO_LIMIT = os_1.default.cpus().length * 4;
function getTreeLayersLeafFirst(tree) {
    var nodes = support_1.bfs(tree);
    var layers = lodash_1.groupBy(nodes, function (x) { return x.depth; });
    var groups = Object.keys(layers)
        .map(Number)
        .sort(function (a, b) { return a - b; })
        .map(function (k) { return layers[String(k)]; })
        .reverse();
    return groups;
}
// first create the tree object, do a reversed breadth first search, getting top contributors for every file and adding to a cache with { absPath, linesCount, topContributor, topContributorPercentage }, every directory has percentage as weighted average on its direct children, then print the tree
function makeTreeWithInfo(cwd, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.silent, silent = _c === void 0 ? false : _c, _d = _b.exclude, exclude = _d === void 0 ? [] : _d;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var tree, layers, bar, linesCounted, _i, layers_1, nodes;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0: return [4 /*yield*/, support_1.gitDirectoryTree(cwd, {
                    // exclude: [
                    //     /node_modules/,
                    //     /\.git/,
                    //     ...gitignoreExclude,
                    //     ...exclude.map((x) => new RegExp(x)),
                    // ], // TODO add excludes
                    })];
                case 1:
                    tree = _e.sent();
                    layers = getTreeLayersLeafFirst(tree);
                    if (!silent) {
                        console.log("processing " + layers.length + " directory tree layers concurrently, with in average " + support_1.average(layers.map(function (x) { return x.length; })).toFixed(1) + " files each");
                    }
                    bar = new cli_progress_1.default.SingleBar({ clearOnComplete: true }, cli_progress_1.default.Presets.shades_classic);
                    if (!silent) {
                        bar.start(layers.map(function (x) { return x.length; }).reduce(support_1.sum, 0), 0);
                    }
                    linesCounted = 0;
                    _i = 0, layers_1 = layers;
                    _e.label = 2;
                case 2:
                    if (!(_i < layers_1.length)) return [3 /*break*/, 5];
                    nodes = layers_1[_i];
                    return [4 /*yield*/, batched_promise_all_1.batchedPromiseAll(nodes, addContributorDetailsToNode, CONCURRENT_IO_LIMIT)];
                case 3:
                    _e.sent();
                    if (!silent) {
                        linesCounted += nodes.length;
                        bar.update(linesCounted);
                    }
                    _e.label = 4;
                case 4:
                    _i++;
                    return [3 /*break*/, 2];
                case 5:
                    bar.stop();
                    return [2 /*return*/, tree];
            }
        });
    });
}
exports.makeTreeWithInfo = makeTreeWithInfo;
var addContributorDetailsToNode = function (node) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    var isDir, filePath, groups_1, totalLines_1, details, _a, author, percentage, lines, authors, hist, contributorsDetails;
    var _b;
    return tslib_1.__generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                isDir = node.type === 'directory';
                filePath = node.path;
                if (isDir && ((_b = node === null || node === void 0 ? void 0 : node.children) === null || _b === void 0 ? void 0 : _b.length)) {
                    groups_1 = lodash_1.groupBy(node.children || [], function (x) { return x.topContributorDetails.author; });
                    totalLines_1 = node.children
                        .map(function (x) { return x.topContributorDetails.accumulatedLinesCount; })
                        .reduce(support_1.sum, 0);
                    details = Object.keys(groups_1).map(function (author) {
                        var nodes = groups_1[author];
                        var lines = nodes
                            .map(function (x) { return x.topContributorDetails.accumulatedLinesCount; })
                            .reduce(support_1.sum, 0);
                        var percentage = lines / totalLines_1;
                        if (percentage > 1) {
                            console.error('WARNING: got a percentage > 1');
                        }
                        return {
                            author: author,
                            lines: lines,
                            percentage: percentage,
                        };
                    });
                    _a = support_1.arrayMax(details, function (x) { return x.percentage; }), author = _a.author, percentage = _a.percentage, lines = _a.lines;
                    node.topContributorDetails = {
                        author: author,
                        percentage: percentage,
                        accumulatedLinesCount: lines,
                    };
                    return [2 /*return*/];
                }
                return [4 /*yield*/, support_1.getFileOwners({
                        filePath: filePath,
                    })];
            case 1:
                authors = _c.sent();
                if (!(authors === null || authors === void 0 ? void 0 : authors.length)) {
                    node.topContributorDetails = {
                        percentage: 0,
                        author: '',
                        accumulatedLinesCount: 0,
                    };
                    return [2 /*return*/];
                }
                hist = support_1.makeHist(authors);
                contributorsDetails = Object.keys(hist).map(function (author) {
                    var lines = hist[author];
                    return {
                        percentage: lines / authors.length,
                        author: author,
                        accumulatedLinesCount: lines,
                    };
                });
                node.topContributorDetails = support_1.arrayMax(contributorsDetails, function (x) { return x.percentage; });
                return [2 /*return*/];
        }
    });
}); };
function getGitIgnoreRegexes() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var gitignorePath, globsToIgnore, _a;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, find_up_1.default('.gitignore')];
                case 1:
                    gitignorePath = _b.sent();
                    globsToIgnore = gitignore_to_glob_1.default(gitignorePath) || [];
                    return [2 /*return*/, globsToIgnore.map(function (x) { return glob_to_regexp_1.default(x, { globstar: true }); })];
                case 2:
                    _a = _b.sent();
                    return [2 /*return*/, []];
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.getGitIgnoreRegexes = getGitIgnoreRegexes;
//# sourceMappingURL=tree.js.map