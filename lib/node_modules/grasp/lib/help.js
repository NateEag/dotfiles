// Generated by LiveScript 1.5.0
(function(){
  var ref$, map, flatten, join, lines, unlines, chars, unchars, syntax, syntaxFlat, aliasMap, attrMapInverse, matchesMap, matchesAliasMap, pad, options, generateSyntaxHelp, generateSyntaxHelpForNode, generateCategoryHelp, generateHelpForCategory;
  ref$ = require('prelude-ls'), map = ref$.map, flatten = ref$.flatten, join = ref$.join, lines = ref$.lines, unlines = ref$.unlines, chars = ref$.chars, unchars = ref$.unchars;
  ref$ = require('grasp-syntax-javascript'), syntax = ref$.syntax, syntaxFlat = ref$.syntaxFlat, aliasMap = ref$.aliasMap, attrMapInverse = ref$.attrMapInverse, matchesMap = ref$.matchesMap, matchesAliasMap = ref$.matchesAliasMap;
  pad = require('./text').pad;
  options = require('./options').options;
  generateSyntaxHelp = function(){
    var maxNameLen, syntaxInfo, res$, category, ref$, nodesInCat, lresult$, nodeName, ref1$, alias, nodes, ref2$, nodeArrays, primitives, getFieldStrings, fieldStrings, nameString, nameStringLen, syntaxInfoStrings, i$, len$, nodesInfo, nodeStrings, prepend, append;
    maxNameLen = 0;
    res$ = [];
    for (category in ref$ = syntax) {
      nodesInCat = ref$[category];
      lresult$ = [];
      for (nodeName in nodesInCat) {
        ref1$ = nodesInCat[nodeName], alias = ref1$.alias, nodes = (ref2$ = ref1$.nodes) != null
          ? ref2$
          : [], nodeArrays = (ref2$ = ref1$.nodeArrays) != null
          ? ref2$
          : [], primitives = (ref2$ = ref1$.primitives) != null
          ? ref2$
          : [];
        getFieldStrings = fn$;
        fieldStrings = getFieldStrings('', nodes).concat(getFieldStrings('%', nodeArrays), getFieldStrings('&', primitives));
        nameString = alias + " (" + nodeName + ")";
        nameStringLen = nameString.length;
        if (nameStringLen > maxNameLen) {
          maxNameLen = nameStringLen;
        }
        lresult$.push([nameString, fieldStrings.join(', ')]);
      }
      res$.push(lresult$);
    }
    syntaxInfo = res$;
    res$ = [];
    for (i$ = 0, len$ = syntaxInfo.length; i$ < len$; ++i$) {
      nodesInfo = syntaxInfo[i$];
      nodeStrings = map(fn1$, nodesInfo);
      res$.push("\n" + unlines(nodeStrings));
    }
    syntaxInfoStrings = res$;
    prepend = 'JavaScript abstract syntax help:\na list of possible node types, and their fields\n`--help node-name` for more information about a node\n`--help categories` for information about categories of nodes\n\nnode-name (FullOfficialName)   field1, field2 (alias), field3...\nfield  - this field contains another node\n%field - this field contains an array of other nodes\n&field - this field contains a primitive value, such as a boolean or a string\n-----------------------------';
    append = 'Based on the Mozilla Parser API <https://developer.mozilla.org/docs/SpiderMonkey/Parser_API>';
    return prepend + "" + unlines(syntaxInfoStrings) + "\n\n" + append;
    function fn$(type, fields){
      return map(function(it){
        var that;
        if (that = attrMapInverse[it]) {
          return type + "" + it + " (" + type + that.join(", " + type) + ")";
        } else {
          return type + "" + it;
        }
      }, fields);
    }
    function fn1$(it){
      return pad(it[0], maxNameLen) + "  " + it[1];
    }
  };
  generateSyntaxHelpForNode = function(nodeName){
    var ref$, alias, nodes, nodeArrays, primitives, syntax, example, note, nameStr, strs, res$, i$, len$, ref1$, type, fields, syntaxStr, exampleStr, examples, ex, line, noteStr;
    ref$ = syntaxFlat[nodeName], alias = ref$.alias, nodes = ref$.nodes, nodeArrays = ref$.nodeArrays, primitives = ref$.primitives, syntax = ref$.syntax, example = ref$.example, note = ref$.note;
    nameStr = alias + " (" + nodeName + ")";
    res$ = [];
    for (i$ = 0, len$ = (ref$ = [['node', nodes], ['node array', nodeArrays], ['primitive', primitives]]).length; i$ < len$; ++i$) {
      ref1$ = ref$[i$], type = ref1$[0], fields = ref1$[1];
      if (fields) {
        res$.push("\n" + type + " fields: " + map(fn$, fields).join(', '));
      }
    }
    strs = res$;
    syntaxStr = syntax ? "\nsyntax:\n" + unlines(map(function(it){
      return "  " + it;
    }, lines(syntax))) : '';
    exampleStr = example ? (examples = (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = [].concat(example)).length; i$ < len$; ++i$) {
        ex = ref$[i$];
        results$.push(unlines((fn$())));
      }
      return results$;
      function fn$(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = lines(ex)).length; i$ < len$; ++i$) {
          line = ref$[i$];
          results$.push("  " + line);
        }
        return results$;
      }
    }()), "\nexample" + (examples.length > 1 ? 's' : '') + ":\n" + unlines(examples)) : '';
    noteStr = note ? "\nnote: " + note : '';
    return nameStr + "\n" + repeatString$('=', nameStr.length) + unchars(strs) + syntaxStr + exampleStr + noteStr;
    function fn$(it){
      var that;
      if (that = attrMapInverse[it]) {
        return it + " (alias: " + that.join(', ') + ")";
      } else {
        return it;
      }
    }
  };
  generateCategoryHelp = function(){
    var categories, res$, alias, ref$, category, fullNodeNames, names, prepend, append;
    res$ = [];
    for (alias in ref$ = matchesAliasMap) {
      category = ref$[alias];
      fullNodeNames = matchesMap[category];
      names = map(fn$, fullNodeNames);
      res$.push(alias + " (" + category + "): " + names.join(', '));
    }
    categories = res$;
    prepend = 'Categories of node types:';
    append = '`--help syntax` for node information.\n`--help category-name` for further information about a category.';
    return prepend + "\n\n" + unlines(categories) + "\n\n" + append;
    function fn$(it){
      return syntaxFlat[it].alias;
    }
  };
  generateHelpForCategory = function(name){
    var invertedAliases, res$, key, ref$, value, alias, fullNodeNames, names, nameStr;
    res$ = {};
    for (key in ref$ = matchesAliasMap) {
      value = ref$[key];
      res$[value] = key;
    }
    invertedAliases = res$;
    alias = invertedAliases[name];
    fullNodeNames = matchesMap[name];
    names = map(function(it){
      return syntaxFlat[it].alias + " (" + it + ")";
    }, fullNodeNames);
    nameStr = alias + " (" + name + ")";
    return "A node type category.\n\n" + nameStr + "\n" + repeatString$('=', nameStr.length) + "\n" + unlines(names);
  };
  module.exports = function(generateHelp, generateHelpForOption, positional, interpolate){
    var helpStrings, res$, i$, len$, arg, lresult$, that, dashes, optionName, j$, ref$, len1$, o, item, sep, name;
    if (positional.length) {
      res$ = [];
      for (i$ = 0, len$ = positional.length; i$ < len$; ++i$) {
        arg = positional[i$];
        lresult$ = [];
        if (arg === 'advanced') {
          lresult$.push(generateHelp({
            showHidden: true,
            interpolate: interpolate
          }));
        } else if (that = /^(--?)(\S+)/.exec(arg)) {
          dashes = that[1], optionName = that[2];
          if (dashes.length === 2) {
            lresult$.push(generateHelpForOption(optionName));
          } else {
            for (j$ = 0, len1$ = (ref$ = chars(optionName)).length; j$ < len1$; ++j$) {
              o = ref$[j$];
              lresult$.push(generateHelpForOption(o));
            }
          }
        } else if (arg === 'more') {
          lresult$.push(generateHelpForOption('help'));
        } else if (arg === 'verbose') {
          for (j$ = 0, len1$ = (ref$ = options).length; j$ < len1$; ++j$) {
            item = ref$[j$];
            if (that = item.heading) {
              sep = repeatString$('#', that.length + 4);
              lresult$.push(sep + "\n# " + that + " #\n" + sep);
            } else {
              lresult$.push(generateHelpForOption(item.option));
            }
          }
        } else if (arg === 'syntax') {
          lresult$.push(generateSyntaxHelp());
        } else if (arg === 'categories') {
          lresult$.push(generateCategoryHelp());
        } else {
          if (aliasMap[arg] || syntaxFlat[arg]) {
            name = aliasMap[arg] || arg;
            lresult$.push(generateSyntaxHelpForNode(name));
          } else if (matchesMap[arg] || matchesAliasMap[arg]) {
            name = matchesAliasMap[arg] || arg;
            lresult$.push(generateHelpForCategory(name));
          } else {
            lresult$.push("No such help option: " + arg + ".");
          }
        }
        res$.push(lresult$);
      }
      helpStrings = res$;
      return join('\n\n')(
      flatten(
      helpStrings));
    } else {
      return generateHelp({
        interpolate: interpolate
      });
    }
  };
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);
