"use strict";
var ts = require("typescript");
var expand = require("glob-expand");
var fs = require("fs");
var path = require("path");
function createDefaultFormatCodeSettings() {
    return {
        indentSize: 4,
        tabSize: 4,
        indentStyle: ts.IndentStyle.Smart,
        newLineCharacter: "\r\n",
        convertTabsToSpaces: true,
        insertSpaceAfterCommaDelimiter: true,
        insertSpaceAfterSemicolonInForStatements: true,
        insertSpaceBeforeAndAfterBinaryOperators: true,
        insertSpaceAfterKeywordsInControlFlowStatements: true,
        insertSpaceAfterFunctionKeywordForAnonymousFunctions: false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,
        insertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: false,
        insertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: false,
        placeOpenBraceOnNewLineForFunctions: false,
        placeOpenBraceOnNewLineForControlBlocks: false,
    };
}
exports.createDefaultFormatCodeSettings = createDefaultFormatCodeSettings;
function getConfigFileName(baseDir, configFileName) {
    var configFilePath = path.resolve(baseDir, configFileName);
    if (fs.existsSync(configFilePath)) {
        return configFilePath;
    }
    if (baseDir.length === path.dirname(baseDir).length) {
        return null;
    }
    return getConfigFileName(path.resolve(baseDir, "../"), configFileName);
}
exports.getConfigFileName = getConfigFileName;
function readFilesFromTsconfig(configPath) {
    var tsconfigDir = path.dirname(configPath);
    var tsconfig = parseJSON(fs.readFileSync(configPath, "utf-8"));
    if (tsconfig.files && (tsconfig.include || tsconfig.exclude)) {
        return tsconfig.files.concat(tsMatchFiles(tsconfig.exclude || [], tsconfig.include || []));
    }
    else if (tsconfig.files) {
        var files = tsconfig.files;
        return files.map(function (filePath) { return path.resolve(tsconfigDir, filePath); });
    }
    else if (tsconfig.filesGlob) {
        return expand({ filter: "isFile", cwd: tsconfigDir }, tsconfig.filesGlob);
    }
    else if (tsconfig.include || tsconfig.exclude) {
        return tsMatchFiles(tsconfig.exclude || [], tsconfig.include || []);
    }
    else {
        throw new Error("No \"files\" or \"filesGlob\" section present in tsconfig.json");
    }
    function tsMatchFiles(excludes, includes) {
        var f = ts.matchFiles;
        if (!f) {
            throw new Error("ts.matchFiles is not exists. typescript@^2.0.0 required");
        }
        return f(tsconfigDir, [".ts", ".tsx"], excludes, includes, true, tsconfigDir, function (dirPath) {
            var stat = fs.statSync(dirPath);
            if (stat.isDirectory()) {
                var result_1 = { files: [], directories: [] };
                var dirEntries = fs.readdirSync(dirPath);
                dirEntries.forEach(function (entry) {
                    var stat = fs.statSync(path.join(dirPath, entry));
                    if (stat.isDirectory()) {
                        result_1.directories.push(entry);
                    }
                    else if (stat.isFile()) {
                        result_1.files.push(entry);
                    }
                });
                return result_1;
            }
            return { files: [], directories: [] };
        });
    }
}
exports.readFilesFromTsconfig = readFilesFromTsconfig;
function parseJSON(jsonText) {
    var result = ts.parseConfigFileTextToJson("tmp.json", jsonText);
    if (result.error) {
        throw new Error("JSON parse error");
    }
    return result.config;
}
exports.parseJSON = parseJSON;
//# sourceMappingURL=utils.js.map