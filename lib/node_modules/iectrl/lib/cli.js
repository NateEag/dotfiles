// Generated by CoffeeScript 1.6.3
var IEVM, Q, addDsl, colors, dsl, find, where,
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Q = require('q');

colors = require('colors');

IEVM = require('./ievm');

exports.columns = function() {
  var c, cols;
  cols = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  return ((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = cols.length; _i < _len; _i++) {
      c = cols[_i];
      _results.push(("" + c + "                                ").slice(0, 32));
    }
    return _results;
  })()).join('');
};

find = function(names) {
  var n, vms, _i, _len, _ref;
  if (!((names != null) && (names.length != null) && names.length > 0)) {
    return IEVM.all();
  }
  vms = [];
  _ref = names.split(',');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    n = _ref[_i];
    vms = vms.concat(IEVM.find(n.trim()));
  }
  return vms;
};

where = function(vms, attr, invert) {
  var vm;
  if (invert == null) {
    invert = false;
  }
  if (attr[0] === '!') {
    attr = attr.slice(1);
    invert = !invert;
  }
  return Q.all((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = vms.length; _i < _len; _i++) {
      vm = vms[_i];
      _results.push(vm[attr]());
    }
    return _results;
  })()).then(function(attrs) {
    var i, vm, _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = vms.length; _i < _len; i = ++_i) {
      vm = vms[i];
      if (invert ? !attrs[i] : attrs[i]) {
        _results.push(vm);
      }
    }
    return _results;
  });
};

dsl = {
  where: function() {
    var attr, attrs, promise, _fn, _i, _len;
    attrs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    promise = this;
    _fn = function(attr) {
      return promise = promise.then(function(vms) {
        return where(vms, attr);
      });
    };
    for (_i = 0, _len = attrs.length; _i < _len; _i++) {
      attr = attrs[_i];
      _fn(attr);
    }
    return addDsl(promise);
  },
  maybeWhere: function() {
    var attrs, maybe;
    maybe = arguments[0], attrs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (maybe) {
      return this.where.apply(this, attrs);
    } else {
      return this;
    }
  },
  found: function(err) {
    return addDsl(this.then(function(vms) {
      if (err == null) {
        err = 'no matching virtual machines found';
      }
      if (vms.length === 0) {
        throw err;
      } else {
        return Q.fcall(function() {
          return vms;
        });
      }
    }));
  },
  all: function(fn, ret) {
    if (ret == null) {
      ret = false;
    }
    return addDsl(this.then(function(vms) {
      var vm;
      return Q.all((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = vms.length; _i < _len; _i++) {
          vm = vms[_i];
          _results.push(Q.fcall(fn, vm));
        }
        return _results;
      })()).then(function(vals) {
        if (ret) {
          return vals;
        } else {
          return vms;
        }
      });
    }));
  },
  seq: function(fn) {
    return this.then(function(vms) {
      var seq, vm, _fn, _i, _len;
      seq = Q();
      _fn = function(vm) {
        return seq = seq.then(function() {
          return Q.fcall(fn, vm);
        });
      };
      for (_i = 0, _len = vms.length; _i < _len; _i++) {
        vm = vms[_i];
        _fn(vm);
      }
      return seq;
    });
  },
  autoStart: function(headless) {
    var _this = this;
    return addDsl(this.then(function(vms) {
      return _this.where('!running').all(function(vm) {
        return vm.start(headless);
      }).then(function() {
        return vms;
      });
    }));
  },
  maybeAutoStart: function(maybe, headless) {
    if (maybe) {
      return this.autoStart(headless);
    } else {
      return this;
    }
  },
  groupReused: function(fn) {
    var group;
    group = function(vms) {
      var rest, vm, win7Names, win7s, xps;
      win7Names = ['IE9 - Win7', 'IE10 - Win7', 'IE11 - Win7'];
      xps = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = vms.length; _i < _len; _i++) {
          vm = vms[_i];
          if (vm.os === 'WinXP') {
            _results.push(vm);
          }
        }
        return _results;
      })();
      win7s = (function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = vms.length; _i < _len; _i++) {
          vm = vms[_i];
          if (_ref = vm.name, __indexOf.call(win7Names, _ref) >= 0) {
            _results.push(vm);
          }
        }
        return _results;
      })();
      rest = (function() {
        var _i, _len, _ref, _results;
        _results = [];
        for (_i = 0, _len = vms.length; _i < _len; _i++) {
          vm = vms[_i];
          if (vm.os !== 'WinXP' && (_ref = vm.name, __indexOf.call(win7Names, _ref) < 0)) {
            _results.push(vm);
          }
        }
        return _results;
      })();
      return [xps, win7s, rest];
    };
    return this.then(group).spread(function(xps, win7s, rest) {
      return fn(addDsl(Q(xps)), addDsl(Q(win7s)), addDsl(Q(rest)));
    });
  }
};

addDsl = function(promise) {
  var m, n;
  for (n in dsl) {
    m = dsl[n];
    promise[n] = m.bind(promise);
  }
  return promise;
};

exports.dsl = function(vms) {
  return addDsl(Q(vms));
};

exports.find = function() {
  var attrs, names;
  names = arguments[0], attrs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  return dsl.where.apply(Q.fcall(function() {
    return find(names);
  }), attrs);
};

exports.fail = function(promise) {
  return promise.fail(function(err) {
    console.error("" + 'ERROR'.red + ": " + err);
    return process.exit(-1);
  });
};
