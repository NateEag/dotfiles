// Generated by LiveScript 1.5.0
(function(){
  var ref$, each, keys, difference, intersection, syntax, syntaxFlat, i$, category, nodeName, node, complexTypes, complexTypeMap, key, val, aliasMap, matchesMap, matchesAliasMap, literals, literalMap, attrMap, attrMapInverse, alias, name, primitiveAttributesSet, nonPrimitiveAttributesSet, that, nonPrimitiveAttributes, primitiveAttributes, eitherAttributes, primitiveOnlyAttributes;
  ref$ = require('prelude-ls'), each = ref$.each, keys = ref$.keys, difference = ref$.difference, intersection = ref$.intersection;
  syntax = {
    Misc: {
      Program: {
        alias: 'program',
        nodeArrays: ['body'],
        note: "The root node of a JavaScript program's AST."
      },
      Identifier: {
        alias: 'ident',
        primitives: ['name'],
        example: 'x'
      },
      Literal: {
        alias: 'literal',
        primitives: ['value'],
        example: ['true', '1', '"string"']
      },
      StringLiteral: {
        alias: 'literal-str',
        primitives: ['value'],
        example: ['"string"']
      },
      NumericLiteral: {
        alias: 'literal-num',
        primitives: ['value'],
        example: ['1']
      },
      BooleanLiteral: {
        alias: 'literal-bool',
        primitives: ['value'],
        example: ['true']
      },
      NullLiteral: {
        alias: 'literal-null',
        primitives: ['value'],
        example: ['null']
      },
      RegExpLiteral: {
        alias: 'regex',
        primitives: ['regex'],
        example: '/^sh+/gi'
      },
      Property: {
        alias: 'prop',
        nodes: ['key', 'value'],
        primitives: ['kind'],
        syntax: '*key*: *value*',
        example: 'a: 1',
        note: 'An object expression (obj) has a list of properties, each being a property.'
      },
      SpreadElement: {
        alias: 'spread',
        nodes: ['argument']
      },
      TemplateElement: {
        alias: 'template-element',
        primitives: ['tail', 'value']
      }
    },
    Statements: {
      EmptyStatement: {
        alias: 'empty',
        example: ';'
      },
      BlockStatement: {
        alias: 'block',
        nodeArrays: ['body'],
        syntax: '{\n  *statement_1*\n  *statement_2*\n  *...*\n  *statement_n*\n}',
        example: '{\n  x = 1;\n  f();\n  x++;\n}'
      },
      ExpressionStatement: {
        alias: 'exp-statement',
        nodes: ['expression'],
        syntax: '*expression*;',
        example: '2;',
        note: 'When an expression is used where a statement should be, it is wrapped in an expression statement.'
      },
      IfStatement: {
        alias: 'if',
        nodes: ['test', 'consequent', 'alternate'],
        syntax: 'if (*test*)\n  *consequent*\n[else\n  *alternate*]',
        example: ['if (even(x)) {\n  f(x);\n}', 'if (x === 2) {\n  x++;\n} else {\n  f(x);\n}']
      },
      LabeledStatement: {
        alias: 'label',
        nodes: ['label', 'body'],
        syntax: '*label*: *body*;',
        example: 'outer:\nfor (i = 0; i < xs.length; i++) {\n  for (j = 0; j < ys.length; j++) {\n    if (xs[i] === ys[j]) {\n      break outer;\n    }\n  }\n}'
      },
      BreakStatement: {
        alias: 'break',
        nodes: ['label'],
        syntax: 'break [*label*];',
        example: ['break;', 'break outer;']
      },
      ContinueStatement: {
        alias: 'continue',
        nodes: ['label'],
        syntax: 'continue [*label*];',
        example: ['continue;', 'continue outerLoop;']
      },
      WithStatement: {
        alias: 'with',
        nodes: ['object', 'body'],
        syntax: 'with (*object*)\n  *body*',
        example: 'with ({x: 42}) {\n  f(x);\n}'
      },
      SwitchStatement: {
        alias: 'switch',
        nodes: ['discriminant'],
        nodeArrays: ['cases'],
        syntax: 'switch (*discriminant*) {\n  *case_1*\n  *case_2*\n  *...*\n  *case_n*\n}',
        example: 'switch (num) {\n  case 1:\n    f(\'one\');\n    break;\n  case 2:\n    f(\'two\');\n    break;\n  default:\n    f(\'too many\');\n}'
      },
      ReturnStatement: {
        alias: 'return',
        nodes: ['argument'],
        syntax: 'return *argument*;',
        example: 'return f(2);'
      },
      ThrowStatement: {
        alias: 'throw',
        nodes: ['argument'],
        syntax: 'throw *argument*;',
        example: 'throw new Error("oops");'
      },
      TryStatement: {
        alias: 'try',
        nodes: ['block', 'handler', 'finalizer'],
        syntax: 'try\n  *block*\n[*handler*]\n[finally\n   *finalizer*]',
        example: 'try {\n  result = parse(input);\n} catch (error) {\n  console.error(error.message);\n  result = \'\';\n} finally {\n  g(result);\n}'
      },
      WhileStatement: {
        alias: 'while',
        nodes: ['test', 'body'],
        syntax: 'while (*test*)\n  *body*',
        example: 'while (x < 2) {\n  f(x);\n  x++;\n}'
      },
      DoWhileStatement: {
        alias: 'do-while',
        nodes: ['test', 'body'],
        syntax: 'do\n  *body*\nwhile (*test*);',
        example: 'do {\n  f(x);\n  x++;\n} while (x < 2);'
      },
      ForStatement: {
        alias: 'for',
        nodes: ['init', 'test', 'update', 'body'],
        syntax: 'for ([*init*]; [*test*]; [*update*])\n  *body*',
        example: 'for (let x = 0; x < 2; x++) {\n  f(x);\n}'
      },
      ForInStatement: {
        alias: 'for-in',
        nodes: ['left', 'right', 'body'],
        syntax: 'for (*left* in *right*)\n  *body*',
        example: 'for (let prop in object) {\n  f(object[prop]);\n}'
      },
      ForOfStatement: {
        alias: 'for-of',
        nodes: ['left', 'right', 'body'],
        syntax: 'for (*left* of *right*)\n  *body*',
        example: 'for (let val of list) {\n  f(val);\n}'
      },
      DebuggerStatement: {
        alias: 'debugger',
        syntax: 'debugger;',
        example: 'debugger;'
      }
    },
    Declarations: {
      FunctionDeclaration: {
        alias: 'func-dec',
        nodes: ['id', 'body'],
        nodeArrays: ['params'],
        primitives: ['generator'],
        syntax: 'function *id*([*param_1*], [*param_2*], [..., *param_3*])\n  *body*',
        example: 'function f(x, y) {\n  return x * y;\n}',
        note: 'A function declaration contrasts with a function expression (func-exp).'
      },
      VariableDeclaration: {
        alias: 'var-decs',
        nodeArrays: ['declarations'],
        primitives: ['kind'],
        syntax: 'var *declaration_1*[, *declaration_2*, ..., *declaration_n*]',
        example: 'var x = 1, y = 2;',
        note: 'Each declaration is a variable declarator (var-dec).'
      },
      VariableDeclarator: {
        alias: 'var-dec',
        nodes: ['id', 'init'],
        syntax: '*id* = *init*',
        example: 'var x = 2'
      }
    },
    Expressions: {
      ThisExpression: {
        alias: 'this',
        example: 'this'
      },
      Super: {
        alias: 'super',
        example: 'super(x, y)'
      },
      ArrayExpression: {
        alias: 'arr',
        nodeArrays: ['elements'],
        syntax: '[*element_0*, *element_1*, *...*, *element_n*]',
        example: ['[1, 2, 3]', '[]']
      },
      ObjectExpression: {
        alias: 'obj',
        nodeArrays: ['properties'],
        syntax: '{\n  *property_1*,\n  *property_2*,\n  *...*,\n  *property_n*\n}',
        example: ['{a: 1, b: 2}', '{}']
      },
      FunctionExpression: {
        alias: 'func-exp',
        nodes: ['id', 'body'],
        nodeArrays: ['params'],
        primitives: ['generator'],
        syntax: 'function [*id*]([*param_1*], [*param_2*], [..., *param_3*])\n  *body*',
        example: 'let f = function(x, y) {\n  return x * y;\n}',
        note: 'A function expression contrasts with a function declaration (func-dec).'
      },
      ArrowFunctionExpression: {
        alias: 'arrow',
        nodes: ['id', 'body'],
        nodeArrays: ['params'],
        primitives: ['generator', 'expression'],
        syntax: '([*param_1*], [*param_2*], [..., *param_3*]) => *body*',
        example: '(x, y) => x * y'
      },
      SequenceExpression: {
        alias: 'seq',
        nodeArrays: ['expressions'],
        syntax: '*expression_1*, *expression_2*, *...*, *expression_n*',
        example: 'a, b, c'
      },
      YieldExpression: {
        alias: 'yield',
        nodes: ['argument'],
        primitive: ['delegate'],
        syntax: 'yield *argument*',
        example: 'yield x'
      },
      UnaryExpression: {
        alias: 'unary',
        nodes: ['argument'],
        primitive: ['operator', 'prefix'],
        syntax: '*operator**argument*',
        example: ['+x', 'typeof x']
      },
      BinaryExpression: {
        alias: 'bi',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: 'x === z'
      },
      AssignmentExpression: {
        alias: 'assign',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: '(y = 2)'
      },
      UpdateExpression: {
        alias: 'update',
        nodes: ['argument'],
        primitives: ['operator', 'prefix'],
        syntax: '*argument**operator*\n\n*or, if prefix*\n\n*operator**argument*',
        example: ['++x', 'x--']
      },
      LogicalExpression: {
        alias: 'logic',
        nodes: ['left', 'right'],
        primitives: ['operator'],
        syntax: '*left* *operator* *right*',
        example: 'x && y'
      },
      ConditionalExpression: {
        alias: 'cond',
        nodes: ['test', 'consequent', 'alternate'],
        syntax: '*test* ? *consequent* : *alternate*',
        example: 'x % 2 ? "odd" : "even"'
      },
      NewExpression: {
        alias: 'new',
        nodes: ['callee'],
        nodeArrays: ['arguments'],
        syntax: 'new *callee*(*argument_1*, *argument_2*, *...*, *argument_n*)',
        example: 'new Date(2011, 11, 11)'
      },
      CallExpression: {
        alias: 'call',
        nodes: ['callee'],
        nodeArrays: ['arguments'],
        syntax: '*callee*(*argument_1*, *argument_2*, *...*, *argument_n*)',
        example: 'f(1,2,3)'
      },
      MemberExpression: {
        alias: 'member',
        nodes: ['object', 'property'],
        primitives: ['computed'],
        syntax: '*object*.*property*',
        example: 'Math.PI'
      },
      TemplateLiteral: {
        alias: 'template-literal',
        nodeArrays: ['quasis', 'expressions']
      },
      TaggedTemplateExpression: {
        alias: 'tagged-template-exp',
        nodes: ['tag', 'quasi']
      }
    },
    Clauses: {
      SwitchCase: {
        alias: 'switch-case',
        nodes: ['test'],
        nodeArrays: ['consequent'],
        syntax: 'case *test* | default :\n  *consequent*',
        example: ['case 1:\n  z = \'one\';\n  break;', 'default:\n  z = \'two\'']
      },
      CatchClause: {
        alias: 'catch',
        nodes: ['param', 'body'],
        syntax: 'catch (*param*)\n  *body*',
        example: 'catch (e) {\n  console.error(e.message);\n}'
      }
    },
    Patterns: {
      AssignmentProperty: {
        alias: 'assign-prop',
        nodes: ['key', 'value'],
        primitives: ['kind', 'method']
      },
      ObjectPattern: {
        alias: 'obj-pattern',
        nodeArrays: ['properties']
      },
      ArrayPattern: {
        alias: 'array-pattern',
        nodeArrays: ['elements']
      },
      RestElement: {
        alias: 'rest-element',
        nodes: ['argument']
      },
      AssignmentPattern: {
        alias: 'assign-pattern',
        nodes: ['left', 'right']
      }
    },
    Classes: {
      ClassBody: {
        alias: 'class-body',
        nodeArrays: ['body']
      },
      MethodDefinition: {
        alias: 'method',
        nodes: ['key', 'value'],
        primitives: ['kind', 'computed', 'static']
      },
      ClassDeclaration: {
        alias: 'class-dec',
        nodes: ['id', 'superClass', 'body']
      },
      ClassExpression: {
        alias: 'class-exp',
        nodes: ['id', 'superClass', 'body']
      },
      MetaProperty: {
        alias: 'meta-property',
        nodes: ['meta', 'property']
      }
    },
    Modules: {
      ModuleDeclaration: {
        alias: 'module-dec'
      },
      ModuleSpecifier: {
        alias: 'module-specifier',
        nodes: ['local']
      }
    },
    Imports: {
      ImportDeclaration: {
        alias: 'import-dec',
        nodes: ['source'],
        nodeArrays: ['specifiers']
      },
      ImportSpecifier: {
        alias: 'import-specifier',
        nodes: ['local', 'imported']
      },
      ImportDefaultSpecifier: {
        alias: 'import-default-specifier',
        nodes: ['local']
      },
      ImportNamespaceSpecifier: {
        alias: 'import-namespace-specifier',
        nodes: ['local']
      }
    },
    Exports: {
      ExportNamedDeclaration: {
        alias: 'export-named-dec',
        nodes: ['declaration', 'source'],
        nodeArrays: ['specifiers']
      },
      ExportSpecifier: {
        alias: 'export-specifier',
        nodes: ['local', 'exported']
      },
      ExportDefaultDeclaration: {
        alias: 'export-default-specifier',
        nodes: ['declaration']
      },
      ExportAllDeclarationSpecifier: {
        alias: 'export-namespace-specifier',
        nodes: ['source']
      }
    },
    JSX: {
      JSXIdentifier: {
        alias: 'jsx-ident',
        primitives: ['name']
      },
      JSXMemberExpression: {
        alias: 'jsx-member',
        nodes: ['object', 'property']
      },
      JSXNamespacedName: {
        alias: 'jsx-namespaced-name',
        nodes: ['namespace', 'name']
      },
      JSXEmptyExpression: {
        alias: 'jsx-empty'
      },
      JSXExpressionContainer: {
        alias: 'jsx-exp-container',
        nodes: ['expression']
      },
      JSXSpreadChild: {
        alias: 'jsx-spread-child',
        nodes: ['expression']
      },
      JSXOpeningElement: {
        alias: 'jsx-open',
        nodes: ['name'],
        nodeArrays: ['attributes'],
        primitives: ['selfClosing']
      },
      JSXClosingElement: {
        alias: 'jsx-close',
        nodes: ['name']
      },
      JSXAttribute: {
        alias: 'jsx-attr',
        nodes: ['name', 'value']
      },
      JSXSpreadAttribute: {
        alias: 'jsx-spread-attr',
        nodes: ['argument']
      },
      JSXElement: {
        alias: 'jsx-element',
        nodes: ['openingElement', 'closingElement'],
        nodeArrays: ['children']
      }
    },
    Types: {
      TypeAnnotation: {
        alias: 'type-annotation'
      },
      TypeAlias: {
        alias: 'type-alias'
      },
      TypeCastExpression: {
        alias: 'type-cast-exp',
        nodes: ['expression']
      },
      InterfaceDeclaration: {
        alias: 'interface-dec'
      }
    }
  };
  syntaxFlat = {};
  for (i$ in syntax) {
    category = syntax[i$];
    for (nodeName in category) {
      node = category[nodeName];
      syntaxFlat[nodeName] = node;
    }
  }
  complexTypes = {
    iife: 'ImmediatelyInvokedFunctionExpression'
  };
  complexTypeMap = {};
  for (key in complexTypes) {
    val = complexTypes[key];
    complexTypeMap[key] = val;
    complexTypeMap[val] = val;
  }
  aliasMap = {};
  for (nodeName in syntaxFlat) {
    node = syntaxFlat[nodeName];
    aliasMap[node.alias] = nodeName;
  }
  matchesMap = {
    Statement: keys(syntax.Statements),
    Declaration: keys(syntax.Declarations),
    Expression: keys(syntax.Expressions),
    Clause: keys(syntax.Clauses),
    BiOp: ['BinaryExpression', 'LogicalExpression', 'AssignmentExpression'],
    Function: ['FunctionDeclaration', 'FunctionExpression'],
    ForLoop: ['ForStatement', 'ForInStatement', 'ForOfStatement'],
    WhileLoop: ['DoWhileStatement', 'WhileStatement'],
    Class: ['ClassExpression', 'ClassExpression'],
    Loop: ['ForStatement', 'ForInStatement', 'ForOfStatement', 'DoWhileStatement', 'WhileStatement']
  };
  matchesAliasMap = {
    statement: 'Statement',
    dec: 'Declaration',
    exp: 'Expression',
    clause: 'Clause',
    biop: 'BiOp',
    func: 'Function',
    'for-loop': 'ForLoop',
    'while-loop': 'WhileLoop',
    loop: 'Loop',
    'class': 'Class'
  };
  literals = {
    'null': 'Null',
    bool: 'Boolean',
    num: 'Number',
    str: 'String',
    regex: 'RegExp'
  };
  literalMap = {};
  for (key in literals) {
    val = literals[key];
    literalMap[key] = val;
    literalMap[val] = val;
  }
  attrMap = {
    exp: 'expression',
    exps: 'expressions',
    then: 'consequent',
    alt: 'alternate',
    'else': 'alternate',
    op: 'operator',
    l: 'left',
    r: 'right',
    arg: 'argument',
    args: 'arguments',
    els: 'elements',
    val: 'value',
    obj: 'object',
    prop: 'property',
    props: 'properties',
    decs: 'declarations'
  };
  attrMapInverse = {};
  for (alias in attrMap) {
    name = attrMap[alias];
    attrMapInverse[name] == null && (attrMapInverse[name] = []);
    attrMapInverse[name].push(alias);
  }
  primitiveAttributesSet = {};
  nonPrimitiveAttributesSet = {};
  for (nodeName in syntaxFlat) {
    node = syntaxFlat[nodeName];
    if (that = node.primitives) {
      each(fn$, that);
    }
    if (that = node.nodes) {
      each(fn1$, that);
    }
    if (that = node.nodeArrays) {
      each(fn2$, that);
    }
  }
  nonPrimitiveAttributes = keys(nonPrimitiveAttributesSet);
  primitiveAttributes = keys(primitiveAttributesSet);
  eitherAttributes = intersection(primitiveAttributes, nonPrimitiveAttributes);
  primitiveOnlyAttributes = difference(primitiveAttributes, nonPrimitiveAttributes);
  module.exports = {
    syntax: syntax,
    syntaxFlat: syntaxFlat,
    complexTypeMap: complexTypeMap,
    aliasMap: aliasMap,
    matchesMap: matchesMap,
    matchesAliasMap: matchesAliasMap,
    literalMap: literalMap,
    attrMap: attrMap,
    attrMapInverse: attrMapInverse,
    primitiveOnlyAttributes: primitiveOnlyAttributes,
    eitherAttributes: eitherAttributes
  };
  function fn$(it){
    return primitiveAttributesSet[it] = true;
  }
  function fn1$(it){
    return nonPrimitiveAttributesSet[it] = true;
  }
  function fn2$(it){
    return nonPrimitiveAttributesSet[it] = true;
  }
}).call(this);
