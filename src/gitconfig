[user]
	name = Nate Eagleson
	email = nate@nateeag.com

[core]
	editor = emacsclient
	excludesfile = ~/.gitignore
	eol = lf

[push]
	default = simple

[merge]
	conflictstyle = diff3

[diff]
    algorithm = patience

[color]
	ui = true

[alias]
    # Handy aliases for subtree merges, based on Pro Git's commentary.
    # Add a remote for the project you're pulling in, add a branch that tracks
    # the remote, git fetch <branch>, checkout master, do
    # 'git subtree-import <path/for/subtree> <branch>, and commit.
    # Whenever you want to pull in updates from the branch, do
    # 'git subtree-merge <branch>'.
    subtree-import = !sh -c \"git read-tree --prefix="$1" -u "$2"\"
    subtree-merge = merge --squash -s subtree --no-commit

    oldest-ancestor = !bash -c 'diff -u <(git rev-list --first-parent "${1:-master}") <(git rev-list --first-parent "${2:-HEAD}") | sed -ne \"s/^ //p\" | head -1' -
    branchdiff = !sh -c \"git diff `git oldest-ancestor`..\"
    branchlog = !sh -c \"git log `git oldest-ancestor`..\"

    # Pretty command-line history.
    graph-log = log --graph --pretty=oneline --decorate --abbrev-commit

    # Useful for working gitflow-style.
    strict-merge = merge --no-commit --no-ff

    # If you have code review, you probably need to delete the same branch in
    # both places fairly frequently.
    # TODO Should accept an optional 2nd param for remote.
    nuke-branch = !sh -c 'git branch -d $1 && git push origin :$1' -

    # Find duplicate files. I had to tweak it for OS X because of non-portable
    # options to uniq, so it's not quite as slick as the original was. It used
    # to output all duplicate objects in the current and the path to them.
    duplicate-objects = !"git ls-tree -r HEAD | cut -c 13- | cut -c 1-40 | uniq -d"

[color]
    interactive = true
